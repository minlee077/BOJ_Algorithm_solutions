/*
Problem:
규현이는 멍청하다. 왜냐하면, 1~10까지 수 밖에 모르기 때문이다. 어느날 규현이 옆을 지나가던 태석이가 규현이를 보고 이렇게 외쳤다. "빵빵!!" 규현이는 "아하!" 하면서 세상에는 빵이란 수도 있구나 했다. 그날 이후로 규현이는 매일 친구들을 볼 때면 "빵빵!!" 거리면서 인사를 했다. 규현이의 친구 중에는 태방이가 있다. 자꾸 규현이가 "빵빵!!" 거릴때 마다 자신을 놀리는 것 처럼 생각했던 태방이는 규현이에게 그건 "빵이 아니고 영이야" 라고 가르쳐 줬다.

이제 규현이는 0~10까지 수를 알고 있다. 어느날 자신이 알고 있는 숫자를 까먹지 않으려고 종이에 1~10까지 수를 썻다. (0은 잠시 까먹었다) 규현이의 친구 석원이는 밀덕이다. 계급을 엄청나게 좋아해서, 규현이가 써 놓은 숫자에 이등병 마크인 -를 모두 그렸다. 석원이는 규현이에게 이렇게 말했다. "너, 우리 위대하신 미하엘 칼라시니코프께서 뭐라고 했는지 알아? 단순함과 신뢰성, 그리고 저렴한 가격이 최고야!"

규현이는 그 말을 듣고서 아하 세상에는 음수도 있구나 했다.

이제 규현이가 아는 수는 -10부터 10까지 20개가 되었다. 아차, 0을 빼먹었구나, 21개가 되었다.

근처 사파리에 놀러간 규현이는 사파리 가이드 승환이와 함께 관광을 시작했다. "저기, 사자 1마리가 보이죠? 그 옆이 그 사자 부인이에요. 그러니깐, 1 더하기 1은 2죠" 규현이는 덧셈을 익혔다. "저 사자는 아까 그 사자의 자식 2마리 입니다. 그럼 총 사자는 몇 마리이지요?" 이제 규현이는 1+1을 제외한 다른 덧셈도 할 수 있다. 만세!

인도네시아에 놀러간 규현이는 자바 섬에 방문했다. 자바 섬에는 자바 커피를 재배하는 홍태석 농부가 있었다. 홍태석은 "ㅋㅋㅋ 님 음수와 양수와 0의 차이도 모름?" 하면서 음수와 양수와 0을 설명해주었다.

지금까지 배운 것을 종합해서, 한국으로 돌아오는 비행기에서 규현이는 종이에 수를 N개 썼다. (규현이가 아는 가장 큰 수는 10이기 때문에, 수를 10개까지만 쓸 수 있다.)  그 다음에, 가능한 모든 N*(N+1)/2개의 구간의 합을 구했다. 이 것을 해인이는 행렬로 표현했다.

규현이가 쓴 수를 A라고 하면, A[i]는 규현이가 i번째 쓴 수이다. 그리고, S[i][j]는 A[i]부터 A[j]까지 합이 0보다 크면 +, 0이면 0, 0보다 작으면 -이다. 여기서 i는 항상 j보다 작거나 같다. 이렇게 배열을 채우면 배열에는 총 N*(N+1)/2개의 문자가 있다. (+, -, 0 중 하나) 이 S 배열이 주어졌을 때, 규현이가 쓴 N개의 수 A를 구해서 출력하면 된다. 규현이는 -10부터 10까지의 정수밖에 모르기 때문에, A도 -10부터 10까지의 정수로만 이루어져 있어야 한다.

Input:
첫째 줄에 수열의 크기 N이 주어진다. N은 10보다 작거나 같은 자연수이다. 둘째 줄에는 N(N+1)/2 길이의 문자열이 주어진다. 처음 N개의 문자는 부호 배열의 첫 번째 줄에 해당하고, 다음 N-1개의 문자는 두 번째 줄에 해당한다. 마찬가지로 마지막 문자는 N번째 줄에 해당하는 문자다.

Output:
첫째 줄에 수열의 원소 N개를 빈 칸을 사이에 두고 출력한다. 답이 여러 가지 일 경우에는 아무거나 출력하면 된다.


Description:
단순하게 브루트포스로 모든 수를 조사하게 되면, 각자리수별로 올 수 있는 수가 21가지이므로, 21^10의 경우의 수가 나오게 된다.
문제를 해결하기 위해선 커팅이 필요하다.
우선, 입력된 부호를 _sign 배열에 저장하게 되면, _sign[i][i]는 i번째 수의 부호(또는 0)이 할당되게 된다.
따라서, 각 자리의 수를 산정할때, 해당 부호의 수만 할당하면 되므로, 이 경우에는 최대 9^10의 경우의 수가 된다.
9^10=약 34억으로, 여전히 너무 큰 경우의 수이다.
또 하나의 특징은 앞에서 부터 수를 한 자리씩 채우게 되면, 특정 자리수까지 조건을 만족하려면, 이전 자리 수까지 조건이 만족되어야 한다.
다시 말해, j열을 채울때는 적어도 j-1열까지는 주어진 조건을 만족해야 한다는 의미다.
따라서, 이에 상응하는 커팅을 하기위해 매 자리수를 채울 상황에 이전 열에 대해 조건을 만족하는지 확인하면, 불필요한 경우의 수가 줄어들게 되므로 계산이 가능할 것이다.

*/
#include <iostream>

using namespace std;

char _sign[10][10];
int ans [10];
int s[10];

bool checker(int i, int j)
{
	int _val = s[j];
	if (i != 0)
		_val -= s[i-1];

	switch (_sign[i][j])
	{
	case '+':
		if (_val > 0)
			return true;
		break;
	case '-':
		if (_val < 0)
			return true;
		break;
	case '0':
		if (_val == 0)
			return true;
		break;
	}
	return false;
}

bool makeStr(int idx, int n)
{
	if (idx == n)
		return true;
	
	if (_sign[idx][idx] == '0')
	{
		ans[idx] = 0;
		if (idx != 0)
			s[idx] = s[idx - 1];
		else
			s[idx] = 0;

		for (int i = 0; i <= idx; i++)
			if (!checker(i, idx))
				return false;

		return makeStr(idx+1,n);
	}
	
	int sig;
	if (_sign[idx][idx] == '+')
		sig = 1;
	else
		sig = -1;
	
	for (int i = 1; i <=10; i++)
	{
		ans[idx]=sig*i;
		s[idx] = sig * i;
		if (idx != 0)
			s[idx] += s[idx-1];

        bool fl=true;
		for (int k = 0; k <= idx; k++)
        {
         if (!checker(k, idx))
         {
            fl=false; 
             break;
         }	
        }
        if(fl ==false)continue;
		if (makeStr(idx + 1, n))
			return true;
		ans[idx] = 0;
		s[idx] = 0;
	}
	return false;
}

int main() {

	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	int n;
	cin >> n;
	
	int temp;
	for (int i = 0; i < n; i++)
		for (int j = i; j < n; j++)
			cin >> _sign[i][j];

	if(makeStr(0, n))
		for(int i =0; i<n; i++)
			cout << ans[i]<<' ';

	return 0;
}